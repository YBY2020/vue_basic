<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>列表排序（和过滤是不割裂开的）</title>
        <!--引入Vue-->
            <script type="text/javascript" src="../js/vue.js"></script>
    </head>
    <body>
        <!--准备好一个容器
        v-for指令用于展示列表数据
        -->
        <div id="root"> 
            <h2>人员列表</h2>
            <input type="text" placeholder="请输入名字" v-model="keyWord"><!-- 模糊搜索 keyWord就是输入的东西-->
            <button @click="sortType = 2">年龄升序</button>
            <button @click="sortType = 1">年龄降序</button>
            <button @click="sortType = 0">原顺序</button>
          <ul>
              <!-- 遍历数组 -->
              <li v-for="(p,index) of filPersons"  :key="p.id">
                {{p.name}}-{{p.age}}--{{p.sex}}
              </li>
             
          </ul>
        </div>
     </body>

   <script type="text/javascript">
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
           
            //用computed实现

            //明显computed实现要比watch简单些，所以优先选用computed
            //vue的目的就是为了不操作真实DOM
            new Vue({
                el:'#root',
                data:{
                    keyWord:'',//keyWord要事先定义
                    sortType:'0',//0原顺序 1降序 2升序
                    persons:[//如果对顺序有要求就用数组
                        {id:'001',name:'马冬梅',age:19,sex:'女'},
                        {id:'002',name:'周冬雨',age:20,sex:'女'},
                        {id:'003',name:'周杰伦',age:21,sex:'男'},
                        {id:'004',name:'温兆伦',age:22,sex:'男'},
                    ], 
                },
                computed:{//计算属性非常之强大，只要改变里面任何一个属性，就会重新计算，所以一开始点击升序就能成功，因为sortType改变了
                        filPersons(){
                             const arr = this.persons.filter((p)=>{
                                return p.name.indexOf(this.keyWord) !== -1
                            }) 
                            //判断一下是否需要排序
                            if (this.sortType){
                                arr.sort((p1,p2)=>{//p1和p2指的是两个人，但不是参数，只是一个模型，如果后减前就是降序，反之升序
                                    return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age

                                })
                            }
                            return arr
                        }
                    },//不能配置在data里面
            })
    </script>
</html>