<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>姓名案例_计算属性实现</title>
        <!--引入Vue-->
            <script type="text/javascript" src="../js/vue.js"></script>
    </head>
    <body>
        <!-- 
            计算属性：
                1.定义：要用的属性不存在，要通过已有属性计算得来（是属性不是随便一个变量）
                2.原理：底层借助了Object.defineProperty方法提供的getter和setter
                3.get函数什么时候执行？1.初次读取fullName时 2.所依赖的数据发生变化时
                4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便
                5.备注：1.计算属性最终会出现在vm身上，直接读取使用即可 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变
         -->
        <!--准备好一个容器-->
        <div id="root"> 
         姓：<input type="text" v-model="firstName"><!-- value是给input框设置初始值，区分提示信息 v-model:value简写为v-model--><br/><br/>
         名：<input type="text" v-model="lastName"><br/><br/>
         全名：<span>{{fullName}}</span><!-- fullName是计算属性，计算属性也是属性，直接插值语法引用就行 -->
        </div>
     </body>

   <script type="text/javascript">
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
        new Vue({
            el:'#root',
            data:{
                firstName:'张',
                lastName:'三'
            },
            computed:{
                fullName:{
                    //get有什么作用?当有人读取fullName是，get就会被调用，且返回值就作为fullName的值
                    //get什么时候调用?1.初次读取fullName时 2.所依赖的数据发生变化时（这就是它对比methods的优势，面试可能会问到的）
                    get(){
                        //console.log(this);//此处的this是vm,直接敲log会关联出console.log()
                        return this.firstName + '-' + this.lastName
                    },
                    //set什么时候调用?当fullName被修改时(其实修改全名就是要修改姓和名，完了他计算出的那个全名就会被修改了)
                    set(value){
                        const arr = value.split('-')//将value传过来的值分割，-前面的是数组元素1，-后面的是数组元素2，-不保存
                        this.firstName=arr[0]
                        this.lastName=arr[1]
                    }
                }
            }
           
        })
    </script>
</html>